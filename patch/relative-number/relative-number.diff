diff --git a/src/editor.zig b/src/editor.zig
index 9e47642..b792a53 100644
--- a/src/editor.zig
+++ b/src/editor.zig
@@ -19,12 +19,19 @@ const ur = @import("uri.zig");
 
 pub const config = Config{
     .end_of_buffer_char = null,
+    .number_line_mode = .absolute,
 };
 
 pub const Config = struct {
     /// Char to denote terminal lines after end of buffer
     /// See vim's :h fillchars -> eob
     end_of_buffer_char: ?u8,
+    number_line_mode: NumberLineMode,
+};
+
+pub const NumberLineMode = enum {
+    absolute,
+    relative,
 };
 
 pub const Dirty = struct {
diff --git a/src/terminal.zig b/src/terminal.zig
index 99cd154..f6fc289 100644
--- a/src/terminal.zig
+++ b/src/terminal.zig
@@ -140,18 +140,40 @@ pub const Terminal = struct {
     fn drawNumberLine(self: *Terminal, buffer: *buf.Buffer, area: Area) !void {
         try co.attributes.write(co.attributes.number_line, self.writer);
         defer self.resetAttributes() catch {};
+        const cursor_row = buffer.cursor.row;
         for (@intCast(area.pos.row)..@as(usize, @intCast(area.pos.row)) + area.dims.height) |term_row| {
             const buffer_row = @as(i32, @intCast(term_row)) + buffer.offset.row;
             try self.moveCursor(.{ .row = @intCast(term_row), .col = area.pos.col });
             if (buffer_row < 0 or buffer_row >= buffer.line_positions.items.len) {
                 if (edi.config.end_of_buffer_char) |ch| _ = try self.writer.writeAll(&.{ch});
             } else {
-                try self.writer.printInt(
-                    @as(usize, @intCast(buffer_row + 1)),
-                    10,
-                    .lower,
-                    .{ .width = area.dims.width - 1, .alignment = .right },
-                );
+                switch (edi.config.number_line_mode) {
+                    .absolute => {
+                        try self.writer.printInt(
+                            @as(usize, @intCast(buffer_row + 1)),
+                            10,
+                            .lower,
+                            .{ .width = area.dims.width - 1, .alignment = .right },
+                        );
+                    },
+                    .relative => {
+                        var display_num: usize = 0;
+                        var alignment: std.fmt.Alignment = .right;
+                        const line_num: i32 = cursor_row - buffer_row;
+                        if (line_num == 0) {
+                            display_num = @intCast(cursor_row + 1);
+                            alignment = .center;
+                        } else {
+                            display_num = @abs(line_num);
+                        }
+                        try self.writer.printInt(
+                            display_num,
+                            10,
+                            .lower,
+                            .{ .width = area.dims.width - 1, .alignment = alignment },
+                        );
+                    },
+                }
             }
         }
     }
