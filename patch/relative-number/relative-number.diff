diff --git a/src/editor.zig b/src/editor.zig
index 8986a02..33c33b4 100644
--- a/src/editor.zig
+++ b/src/editor.zig
@@ -24,6 +24,12 @@ pub const Config = struct {
     /// Attempt to find matching pair when cursor is over one of these [start, end] chars
     /// If start == end, will only check forward until first encountered match
     pub const matching_pair_chars: ?[]const [2]u21 = &.{ .{ '{', '}' }, .{ '[', ']' }, .{ '(', ')' }, .{ '<', '>' }, .{ '|', '|' } };
+    pub const number_line_mode: NumberLineMode = .absolute;
+};
+
+pub const NumberLineMode = enum {
+    absolute,
+    relative,
 };
 
 pub const Dirty = struct {
diff --git a/src/terminal.zig b/src/terminal.zig
index 908d5e8..66533e0 100644
--- a/src/terminal.zig
+++ b/src/terminal.zig
@@ -140,18 +140,40 @@ pub const Terminal = struct {
     fn drawNumberLine(self: *Terminal, buffer: *buf.Buffer, area: Area) !void {
         try co.Attribute.writeSlice(co.Attribute.number_line, self.writer);
         defer self.resetAttribute() catch {};
+        const cursor_row = buffer.cursor.row;
         for (@intCast(area.pos.row)..@as(usize, @intCast(area.pos.row)) + area.dims.height) |term_row| {
             const buffer_row = @as(i32, @intCast(term_row)) + buffer.offset.row;
             try self.moveCursor(.{ .row = @intCast(term_row), .col = area.pos.col });
             if (buffer_row < 0 or buffer_row >= buffer.line_positions.items.len) {
                 if (edi.Config.end_of_buffer_char) |ch| _ = try self.writer.writeAll(&.{ch});
             } else {
-                try self.writer.printInt(
-                    @as(usize, @intCast(buffer_row + 1)),
-                    10,
-                    .lower,
-                    .{ .width = area.dims.width - 1, .alignment = .right },
-                );
+                switch (edi.Config.number_line_mode) {
+                    .absolute => {
+                        try self.writer.printInt(
+                            @as(usize, @intCast(buffer_row + 1)),
+                            10,
+                            .lower,
+                            .{ .width = area.dims.width - 1, .alignment = .right },
+                        );
+                    },
+                    .relative => {
+                        var display_num: usize = 0;
+                        var alignment: std.fmt.Alignment = .right;
+                        const line_num: i32 = cursor_row - buffer_row;
+                        if (line_num == 0) {
+                            display_num = @intCast(cursor_row + 1);
+                            alignment = .center;
+                        } else {
+                            display_num = @abs(line_num);
+                        }
+                        try self.writer.printInt(
+                            display_num,
+                            10,
+                            .lower,
+                            .{ .width = area.dims.width - 1, .alignment = alignment },
+                        );
+                    },
+                }
             }
         }
     }
