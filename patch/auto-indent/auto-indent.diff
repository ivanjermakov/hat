diff --git a/src/buffer.zig b/src/buffer.zig
index f3c72f9..92ff3eb 100644
--- a/src/buffer.zig
+++ b/src/buffer.zig
@@ -564,62 +564,87 @@ pub const Buffer = struct {
         log.trace(@This(), "line byte positions: {any}\n", .{self.line_positions.items});
     }
 
-    pub fn updateIndents(self: *Buffer) FatalError!void {
-        if (self.ts_state == null or self.ts_state.?.indent == null) return;
-        try self.reparse();
-
-        self.indents.clearRetainingCapacity();
-        for (0..self.line_byte_positions.items.len) |row| {
-            try self.indents.append(self.allocator, try self.lineIndent(row));
-        }
-        log.debug(@This(), "indents: {any}\n", .{self.indents.items});
-    }
-
     pub fn lineIndent(self: *Buffer, row: usize) FatalError!usize {
         const ts_state = if (self.ts_state) |ts_state| ts_state else return 0;
         const query = ts_state.indent orelse return 0;
-        if (self.lineLength(row) == 0 and row > 0) return self.lineIndent(row - 1);
         const root_node = ts.ts.ts_tree_root_node(ts_state.tree);
 
         const line_span = SpanFlat{
             .start = if (row == 0) 0 else self.line_byte_positions.items[row - 1],
             .end = self.line_byte_positions.items[row],
         };
-        if (ts.firstSmallestDescendentInSpan(root_node, line_span)) |node| {
-            log.trace(@This(), "line {} {}\n", .{ row + 1, line_span });
-            var n = node;
-            var indent: i32 = 0;
-            var processed_rows = std.AutoHashMap(usize, void).init(self.allocator);
-            defer processed_rows.deinit();
-            while (!ts.ts.ts_node_is_null(n)) {
-                const span = SpanFlat{
-                    .start = ts.ts.ts_node_start_byte(n),
-                    .end = ts.ts.ts_node_end_byte(n),
-                };
-                log.trace(@This(), "node {}\n", .{span});
-                if (query.captures.get(@intFromPtr(n.id))) |cap| c: {
-                    const pos = Span.fromSpanFlat(self, span);
+        log.trace(@This(), "indent line {} {}\n", .{ row + 1, line_span });
 
+        var n: ?ts.ts.TSNode = null;
+        if (line_span.start > 2 and self.lineLength(row) == 0) {
+            // assumes no trailing spaces on prev line
+            const prev_line_end_span = SpanFlat{ .start = line_span.start - 2, .end = line_span.start - 1 };
+            n = ts.firstSmallestDescendentInSpan(root_node, prev_line_end_span);
+            if (n) |n_| {
+                if (query.captures.get(@intFromPtr(n_.id))) |cap| {
                     var capture_name_len: u32 = undefined;
                     const capture_name_buf = ts.ts.ts_query_capture_name_for_id(query.query.?, cap.index, &capture_name_len);
                     const capture_name = capture_name_buf[0..capture_name_len];
-                    log.trace(@This(), "capture {s} [{}-{}]\n", .{ capture_name, span.start, span.end });
-
-                    if (processed_rows.contains(@intCast(pos.start.row))) break :c;
-                    if (pos.start.row != pos.end.row and pos.start.row != row and std.mem.eql(u8, capture_name, "indent.begin")) {
-                        indent += 1;
-                        try processed_rows.put(@intCast(pos.start.row), {});
-                    } else if (std.mem.eql(u8, capture_name, "indent.end") or std.mem.eql(u8, capture_name, "indent.branch")) {
-                        indent -= 1;
+                    if (std.mem.eql(u8, capture_name, "indent.end") or std.mem.eql(u8, capture_name, "indent.branch")) {
+                        n = ts.firstSmallestDescendentInSpan(root_node, line_span);
                     }
                 }
-                n = ts.ts.ts_node_parent(n);
             }
-            return if (indent < 0) 0 else @intCast(indent);
         } else {
-            log.trace(@This(), "line {}[{}-{}] no node\n", .{ row + 1, line_span.start, line_span.end });
+            n = ts.firstSmallestDescendentInSpan(root_node, line_span);
+        }
+        if (n == null) {
+            log.warn(@This(), "no node\n", .{});
             return 0;
         }
+        var node = n.?;
+        const indent_row: usize = @intCast(self.posToCursor(ts.ts.ts_node_start_byte(node)).row);
+
+        var indent: i32 = 0;
+        var processed_rows = std.AutoHashMap(usize, void).init(self.allocator);
+        defer processed_rows.deinit();
+        while (!ts.ts.ts_node_is_null(node)) {
+            const span = SpanFlat{
+                .start = ts.ts.ts_node_start_byte(node),
+                .end = ts.ts.ts_node_end_byte(node),
+            };
+            log.trace(@This(), "node {}\n", .{span});
+            if (query.captures.get(@intFromPtr(node.id))) |cap| c: {
+                const pos = Span.fromSpanFlat(self, span);
+
+                var capture_name_len: u32 = undefined;
+                const capture_name_buf = ts.ts.ts_query_capture_name_for_id(query.query.?, cap.index, &capture_name_len);
+                const capture_name = capture_name_buf[0..capture_name_len];
+                log.trace(@This(), "capture {s} [{}-{}]\n", .{ capture_name, span.start, span.end });
+
+                if (processed_rows.contains(@intCast(pos.start.row))) break :c;
+                if (pos.start.row != pos.end.row and pos.start.row != indent_row and std.mem.eql(u8, capture_name, "indent.begin")) {
+                    indent += 1;
+                    try processed_rows.put(@intCast(pos.start.row), {});
+                } else if (std.mem.eql(u8, capture_name, "indent.end") or std.mem.eql(u8, capture_name, "indent.branch")) {
+                    indent -= 1;
+                }
+            }
+            node = ts.ts.ts_node_parent(node);
+        }
+        return if (indent < 0) 0 else @intCast(indent);
+    }
+
+    pub fn indentEmptyLine(self: *Buffer) FatalError!void {
+        if (self.ts_state == null) return;
+        std.debug.assert(self.cursor.col == 0);
+        try self.reparse();
+        if (self.lineLength(@intCast(self.cursor.row)) != 0) return;
+
+        const correct_indent: usize = try self.lineIndent(@intCast(self.cursor.row));
+        const correct_indent_spaces = correct_indent * self.file_type.indent_spaces;
+        if (correct_indent_spaces > 0) {
+            const indent_text = try self.allocator.alloc(u21, correct_indent_spaces);
+            defer self.allocator.free(indent_text);
+            @memset(indent_text, ' ');
+            var indent_change = try cha.Change.initInsert(self.allocator, self, self.cursor, indent_text);
+            try self.appendChange(&indent_change);
+        }
     }
 
     pub fn undo(self: *Buffer) !void {
diff --git a/src/editor.zig b/src/editor.zig
index 8986a02..eaa0bf0 100644
--- a/src/editor.zig
+++ b/src/editor.zig
@@ -24,6 +24,10 @@ pub const Config = struct {
     /// Attempt to find matching pair when cursor is over one of these [start, end] chars
     /// If start == end, will only check forward until first encountered match
     pub const matching_pair_chars: ?[]const [2]u21 = &.{ .{ '{', '}' }, .{ '[', ']' }, .{ '(', ')' }, .{ '<', '>' }, .{ '|', '|' } };
+    /// In buffers with TS indent support, autoindent inserted newline
+    pub const indent_newline: bool = false;
+    /// In buffers with TS indent support, reindent current line upon insertion of one of these chars
+    pub const reindent_block_end_chars: ?[]const u21 = null;
 };
 
 pub const Dirty = struct {
diff --git a/src/main.zig b/src/main.zig
index d117195..44b359a 100644
--- a/src/main.zig
+++ b/src/main.zig
@@ -220,6 +220,17 @@ pub fn startEditor(allocator: std.mem.Allocator) FatalError!void {
                         if (next_key != null and next_key.?.printable != null) {
                             try printable.append(allocator, next_key.?.printable.?);
                             keys_consumed += 1;
+                            if (edi.Config.indent_newline and keys_consumed == 1 and next_key.?.printable == '\n') {
+                                try buffer.changeInsertText(try printable.toOwnedSlice(allocator));
+                                try buffer.indentEmptyLine();
+                            }
+                            if (edi.Config.reindent_block_end_chars != null and
+                                std.mem.containsAtLeastScalar(u21, edi.Config.reindent_block_end_chars.?, 1, next_key.?.printable.?))
+                            {
+                                try buffer.changeInsertText(try printable.toOwnedSlice(allocator));
+                                log.warn(@This(), "align!!!\n", .{});
+                                try buffer.changeAlignIndent();
+                            }
                         } else {
                             break;
                         }
@@ -427,6 +438,9 @@ pub fn startEditor(allocator: std.mem.Allocator) FatalError!void {
                     var change = try cha.Change.initInsert(allocator, buffer, pos, &.{'\n'});
                     try buffer.appendChange(&change);
                     if (!below) buffer.moveCursor(.{ .row = row });
+                    if (edi.Config.indent_newline) {
+                        try buffer.indentEmptyLine();
+                    }
                 } else if (buffer.mode == .normal and eql(u8, key, "J")) {
                     for (0..@intCast(repeat_or_1)) |_| {
                         if (buffer.cursor.row + 1 < buffer.line_positions.items.len) {
diff --git a/src/ts.zig b/src/ts.zig
index a7de638..bfd6d5e 100644
--- a/src/ts.zig
+++ b/src/ts.zig
@@ -213,7 +213,7 @@ pub fn firstSmallestDescendentInSpan(node: ts.TSNode, span: SpanFlat) ?ts.TSNode
 
     if (node_end < span.start) return null;
     const child_count = ts.ts_node_child_count(node);
-    if (child_count == 0 and node_start >= span.start and node_end <= span.end) return node;
+    if (child_count == 0 and node_start >= span.start) return node;
 
     for (0..child_count) |child_idx| {
         const child_candidate = ts.ts_node_child(node, @intCast(child_idx));
