diff --git a/src/buffer.zig b/src/buffer.zig
index 0f31b8e..ef9db7c 100644
--- a/src/buffer.zig
+++ b/src/buffer.zig
@@ -24,6 +24,7 @@ const main = @import("main.zig");
 const ter = @import("terminal.zig");
 const ts = @import("ts.zig");
 const dia = @import("ui/diagnostic.zig");
+const act = @import("ui/code_action.zig");
 const uni = @import("unicode.zig");
 const ur = @import("uri.zig");
 
@@ -187,6 +188,7 @@ pub const Buffer = struct {
 
     pub fn enterMode(self: *Buffer, mode: Mode) FatalError!void {
         main.editor.resetHover();
+        main.editor.resetCodeActions();
 
         if (self.mode == mode) return;
         if (self.mode == .insert) try self.commitChanges();
@@ -312,6 +314,7 @@ pub const Buffer = struct {
 
         main.editor.dirty.cursor = true;
         main.editor.resetHover();
+        main.editor.resetCodeActions();
     }
 
     pub fn centerCursor(self: *Buffer) void {
@@ -628,6 +631,12 @@ pub const Buffer = struct {
         return self.content_raw.items[bs.start..bs.end];
     }
 
+    pub fn codeActionExecute(self: *Buffer, code_action: act.CodeAction) !void {
+        const parse_result = try std.json.parseFromSlice(lsp.types.WorkspaceEdit, self.allocator, code_action.edit_json, .{});
+        defer parse_result.deinit();
+        try main.editor.applyWorkspaceEdit(parse_result.value);
+    }
+
     pub fn renamePrompt(self: *Buffer) !void {
         const cmd = &main.editor.command_line;
         const line = self.lineContent(@intCast(self.cursor.row));
diff --git a/src/editor.zig b/src/editor.zig
index 4ba3924..ef84753 100644
--- a/src/editor.zig
+++ b/src/editor.zig
@@ -13,6 +13,7 @@ const main = @import("main.zig");
 const ter = @import("terminal.zig");
 const cmd = @import("ui/command_line.zig");
 const cmp = @import("ui/completion_menu.zig");
+const act = @import("ui/code_action.zig");
 const fzf = @import("ui/fzf.zig");
 const uni = @import("unicode.zig");
 const ur = @import("uri.zig");
@@ -50,6 +51,7 @@ pub const Editor = struct {
     messages: std.array_list.Aligned([]const u8, null) = .empty,
     message_read_idx: usize = 0,
     hover_contents: ?[]const u8 = null,
+    code_actions: ?[]const act.CodeAction = null,
     key_queue: std.array_list.Aligned(inp.Key, null) = .empty,
     dot_repeat_input: std.array_list.Aligned(inp.Key, null) = .empty,
     dot_repeat_input_uncommitted: std.array_list.Aligned(inp.Key, null) = .empty,
@@ -154,6 +156,7 @@ pub const Editor = struct {
         self.messages.deinit(self.allocator);
 
         self.resetHover();
+        self.resetCodeActions();
 
         self.key_queue.deinit(self.allocator);
         self.dot_repeat_input.deinit(self.allocator);
@@ -328,6 +331,15 @@ pub const Editor = struct {
         }
     }
 
+    pub fn resetCodeActions(self: *Editor) void {
+        if (self.code_actions) |code_actions| {
+            for (code_actions) |code_action| code_action.deinit();
+            self.allocator.free(code_actions);
+            self.code_actions = null;
+            main.editor.dirty.draw = true;
+        }
+    }
+
     pub fn writeInputString(self: *Editor, str: []const u8) FatalError!void {
         const keys = try ter.getKeys(self.allocator, str);
         defer self.allocator.free(keys);
diff --git a/src/lsp.zig b/src/lsp.zig
index 015292e..722c952 100644
--- a/src/lsp.zig
+++ b/src/lsp.zig
@@ -9,12 +9,14 @@ const buf = @import("buffer.zig");
 const cha = @import("change.zig");
 const core = @import("core.zig");
 const Cursor = core.Cursor;
+const Span = core.Span;
 const fs = @import("fs.zig");
 const log = @import("log.zig");
 const main = @import("main.zig");
 const fzf = @import("ui/fzf.zig");
 const dia = @import("ui/diagnostic.zig");
 const ur = @import("uri.zig");
+const act = @import("ui/code_action.zig");
 
 pub const lsp_config = [_]LspConfig{};
 
@@ -93,6 +95,7 @@ pub const LspConnection = struct {
                 .rename = .{
                     .prepareSupport = true,
                 },
+                .codeAction = .{},
             },
             .workspace = .{
                 .workspaceFolders = true,
@@ -185,6 +188,8 @@ pub const LspConnection = struct {
                         try self.handleHoverResponse(arena.allocator(), response_result);
                     } else if (std.mem.eql(u8, method, "textDocument/rename")) {
                         try self.handleRenameResponse(arena.allocator(), response_result);
+                    } else if (std.mem.eql(u8, method, "textDocument/codeAction")) {
+                        try self.handleCodeActionResponse(arena.allocator(), response_result);
                     }
                 },
                 .notification => |notif| {
@@ -236,6 +241,15 @@ pub const LspConnection = struct {
         });
     }
 
+    pub fn codeAction(self: *LspConnection) !void {
+        const buffer = main.editor.active_buffer;
+        try self.sendRequest("textDocument/codeAction", .{
+            .textDocument = .{ .uri = buffer.uri },
+            .range = (Span{ .start = buffer.cursor, .end = buffer.cursor }).toLsp(),
+            .context = .{ .diagnostics = &.{} },
+        });
+    }
+
     pub fn rename(self: *LspConnection, new_name: []const u8) !void {
         if ((self.server_init orelse return).value.capabilities.renameProvider == null) return;
         const buffer = main.editor.active_buffer;
@@ -521,6 +535,18 @@ pub const LspConnection = struct {
         try main.editor.applyWorkspaceEdit(result.value);
     }
 
+    fn handleCodeActionResponse(self: *LspConnection, arena: Allocator, resp: ?std.json.Value) !void {
+        _ = self;
+        if (resp == null or resp.? == .null) return;
+        const result = try std.json.parseFromValue([]const types.CodeAction, arena, resp.?, .{});
+        const editor = &main.editor;
+
+        editor.resetCodeActions();
+        editor.code_actions = try act.fromLsp(editor.allocator, result.value);
+        log.debug(@This(), "got {} code actions\n", .{editor.code_actions.?.len});
+        editor.dirty.draw = true;
+    }
+
     fn handleNotification(self: *LspConnection, arena: Allocator, notif: lsp.JsonRPCMessage.Notification) !void {
         log.trace(@This(), "notification: {s}\n", .{notif.method});
         if (std.mem.eql(u8, notif.method, "window/logMessage")) {
diff --git a/src/main.zig b/src/main.zig
index 066118d..4834fb0 100644
--- a/src/main.zig
+++ b/src/main.zig
@@ -167,6 +167,14 @@ pub fn startEditor(allocator: std.mem.Allocator) FatalError!void {
                 const cmd_active = editor.command_line.command != null;
                 var repeat_or_1: i32 = 1;
                 if (repeat_count) |rc| repeat_or_1 = @intCast(rc);
+                const code_action = if (editor.code_actions) |code_actions| b: {
+                    if (raw_key.printable) |printable| {
+                        for (code_actions) |action| {
+                            if (action.hint == printable) break :b action;
+                        }
+                    }
+                    break :b null;
+                } else null;
 
                 // command line menu
                 if (cmd_active) {
@@ -194,6 +202,10 @@ pub fn startEditor(allocator: std.mem.Allocator) FatalError!void {
                 } else if (cmp_menu_active and eql(u8, key, "\n")) {
                     editor.completion_menu.accept() catch |e| log.err(@This(), "cmp accept error: {}\n", .{e});
 
+                    // code action menu
+                } else if (code_action) |action| {
+                    buffer.codeActionExecute(action) catch |e| log.err(@This(), "code action exec error: {}\n", .{e});
+
                     // text insertion
                 } else if (buffer.mode == .insert and editor.key_queue.items[0].printable != null) {
                     var printable: std.array_list.Aligned(u21, null) = .empty;
@@ -436,6 +448,10 @@ pub fn startEditor(allocator: std.mem.Allocator) FatalError!void {
                         for (buffer.lsp_connections.items) |conn| {
                             conn.findReferences() catch |e| log.err(@This(), "find references LSP error: {}\n", .{e});
                         }
+                    } else if (buffer.mode == .normal and eql(u8, multi_key, " c")) {
+                        for (buffer.lsp_connections.items) |conn| {
+                            conn.codeAction() catch |e| log.err(@This(), "code action LSP error: {}\n", .{e});
+                        }
                     } else if (buffer.mode == .normal and eql(u8, multi_key, " n")) {
                         try buffer.renamePrompt();
                     } else if (buffer.mode == .normal and eql(u8, key, "r") and key2.printable != null) {
diff --git a/src/terminal.zig b/src/terminal.zig
index f18974d..59e4ef7 100644
--- a/src/terminal.zig
+++ b/src/terminal.zig
@@ -15,6 +15,7 @@ const log = @import("log.zig");
 const main = @import("main.zig");
 const cmd = @import("ui/command_line.zig");
 const cmp = @import("ui/completion_menu.zig");
+const act = @import("ui/code_action.zig");
 const uni = @import("unicode.zig");
 const ft = @import("file_type.zig");
 
@@ -81,6 +82,7 @@ pub const Terminal = struct {
         try self.drawCompletionMenu(cmp_menu);
 
         if (main.editor.hover_contents) |hover| try self.drawHover(hover, layout.buffer);
+        if (main.editor.code_actions) |code_actions| try self.drawCodeActions(code_actions, layout.buffer);
         if (main.editor.command_line.command == null) try self.drawMessage();
         try self.updateCursor();
         if (main.editor.command_line.command != null) try self.drawCmd(&main.editor.command_line);
@@ -335,6 +337,34 @@ pub const Terminal = struct {
         try self.drawOverlay(doc_lines.items, doc_pos);
     }
 
+    fn drawCodeActions(self: *Terminal, code_actions: []const act.CodeAction, area: Area) !void {
+        var overlay_lines: std.array_list.Aligned([]const u8, null) = .empty;
+        defer {
+            for (overlay_lines.items) |l| self.allocator.free(l);
+            overlay_lines.deinit(self.allocator);
+        }
+        for (code_actions) |code_action| {
+            const line = try std.fmt.allocPrint(self.allocator, "[{c}] {s}", .{ code_action.hint, code_action.title });
+            try overlay_lines.append(self.allocator, line);
+        }
+        const buffer = main.editor.active_buffer;
+        const max_doc_width = 90;
+        var longest_line: usize = 0;
+        for (overlay_lines.items) |line| {
+            if (line.len > longest_line) longest_line = line.len;
+        }
+        var pos = buffer.cursor
+            .applyOffset(buffer.offset.negate())
+            .applyOffset(area.pos)
+            .applyOffset(.{ .row = 1 });
+        const overlay_width = @min(max_doc_width, longest_line);
+        if (pos.col + overlay_width > self.dimensions.width) {
+            pos.col = @max(0, @as(i32, @intCast(self.dimensions.width)) - overlay_width);
+        }
+        std.debug.print("{any}\n", .{overlay_lines.items});
+        try self.drawOverlay(overlay_lines.items, pos);
+    }
+
     /// Draw a box on top of the editor's content, containing `lines`
     /// Box width is min(longest line, available area)
     fn drawOverlay(self: *Terminal, lines: []const []const u8, pos: Cursor) !void {
diff --git a/src/ui/code_action.zig b/src/ui/code_action.zig
new file mode 100644
index 0000000..8246f40
--- /dev/null
+++ b/src/ui/code_action.zig
@@ -0,0 +1,67 @@
+const std = @import("std");
+const Allocator = std.mem.Allocator;
+
+const lsp = @import("../lsp.zig");
+
+pub const hint_bag: []const u8 = &.{ 'f', 'j', 'd', 'k', 's', 'l', 'a', 'b', 'c', 'e', 'g', 'h', 'i', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z' };
+
+pub const CodeAction = struct {
+    hint: u8,
+    title: []const u8,
+    /// Stringified `lsp.types.WorkspaceEdit`
+    edit_json: []const u8,
+    allocator: Allocator,
+
+    pub fn init(allocator: Allocator, code_action: lsp.types.CodeAction) !CodeAction {
+        const title = try allocator.dupe(u8, code_action.title);
+        return .{
+            .hint = title[0],
+            .title = title,
+            .edit_json = try std.json.Stringify.valueAlloc(allocator, code_action.edit.?, .{}),
+            .allocator = allocator,
+        };
+    }
+
+    pub fn deinit(self: *const CodeAction) void {
+        self.allocator.free(self.title);
+        self.allocator.free(self.edit_json);
+    }
+};
+
+pub fn fromLsp(allocator: Allocator, lsp_code_actions: []const lsp.types.CodeAction) ![]const CodeAction {
+    var bag: std.array_list.Aligned(u8, null) = .empty;
+    try bag.appendSlice(allocator, hint_bag);
+    defer bag.deinit(allocator);
+    var code_actions = std.array_list.Managed(CodeAction).init(allocator);
+    for (lsp_code_actions) |lsp_code_action| {
+        var action = try CodeAction.init(allocator, lsp_code_action);
+        if (std.mem.indexOfScalar(u8, bag.items, action.hint)) |available_idx| {
+            _ = bag.orderedRemove(available_idx);
+        } else {
+            action.hint = bag.orderedRemove(0);
+        }
+        try code_actions.append(action);
+    }
+    return try code_actions.toOwnedSlice();
+}
+
+test "fromLsp with collisions" {
+    const allocator = std.testing.allocator;
+    const result = try fromLsp(allocator, &.{
+        .{ .title = "foo", .edit = .{} },
+        .{ .title = "bar", .edit = .{} },
+        .{ .title = "baz", .edit = .{} },
+        .{ .title = "doo", .edit = .{} },
+        .{ .title = "bax", .edit = .{} },
+    });
+    defer {
+        for (result) |a| a.deinit();
+        allocator.free(result);
+    }
+
+    try std.testing.expectEqual('f', result[0].hint);
+    try std.testing.expectEqual('b', result[1].hint);
+    try std.testing.expectEqual('j', result[2].hint);
+    try std.testing.expectEqual('d', result[3].hint);
+    try std.testing.expectEqual('k', result[4].hint);
+}
