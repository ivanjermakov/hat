diff --git a/src/core.zig b/src/core.zig
index a09c2e0..e7baaa1 100644
--- a/src/core.zig
+++ b/src/core.zig
@@ -105,6 +105,7 @@ pub const SpanFlat = struct {
 };
 
 pub const Layout = struct {
+    left_padding: Area,
     number_line: Area,
     buffer: Area,
 };
diff --git a/src/editor.zig b/src/editor.zig
index 8986a02..b3db7dc 100644
--- a/src/editor.zig
+++ b/src/editor.zig
@@ -24,6 +24,11 @@ pub const Config = struct {
     /// Attempt to find matching pair when cursor is over one of these [start, end] chars
     /// If start == end, will only check forward until first encountered match
     pub const matching_pair_chars: ?[]const [2]u21 = &.{ .{ '{', '}' }, .{ '[', ']' }, .{ '(', ')' }, .{ '<', '>' }, .{ '|', '|' } };
+    /// Imaginary width of a buffer that should be aligned (padded on the left).
+    /// `null` means "no centering".
+    /// If >`term_width`, padding is 0,
+    /// If <`term_width`, left padding is `(term_width-centering_width)/2`
+    pub const centering_width: ?usize = null;
 };
 
 pub const Dirty = struct {
diff --git a/src/terminal.zig b/src/terminal.zig
index 908d5e8..399018f 100644
--- a/src/terminal.zig
+++ b/src/terminal.zig
@@ -79,7 +79,7 @@ pub const Terminal = struct {
         try self.drawBuffer(buffer, layout.buffer);
 
         const cmp_menu = &main.editor.completion_menu;
-        try self.drawCompletionMenu(cmp_menu);
+        try self.drawCompletionMenu(cmp_menu, layout.buffer);
 
         if (main.editor.hover_contents) |hover| try self.drawHover(hover, layout.buffer);
         if (main.editor.command_line.command == null) try self.drawMessage();
@@ -249,7 +249,7 @@ pub const Terminal = struct {
         }
     }
 
-    fn drawCompletionMenu(self: *Terminal, cmp_menu: *cmp.CompletionMenu) !void {
+    fn drawCompletionMenu(self: *Terminal, cmp_menu: *cmp.CompletionMenu, area: Area) !void {
         const max_width = 30;
         const buffer = main.editor.active_buffer;
 
@@ -262,6 +262,7 @@ pub const Terminal = struct {
             .col = @intCast(replace_range.start.character),
         })
             .applyOffset(buffer.offset.negate())
+            .applyOffset(area.pos)
             .applyOffset(.{ .row = 1 });
 
         var longest_item: usize = 0;
@@ -405,20 +406,32 @@ pub fn terminalSize() !Dimensions {
 
 pub fn computeLayout(term_dims: Dimensions) Layout {
     const number_line_width = 5;
+    const padding_width = if (edi.Config.centering_width) |cw|
+        if (term_dims.width > cw) @divFloor(term_dims.width - cw, 2) else 0
+    else
+        0;
+    const occupied_width = padding_width + number_line_width;
 
     return .{
-        .number_line = .{
+        .left_padding = .{
             .pos = .{},
+            .dims = .{
+                .height = term_dims.height,
+                .width = padding_width,
+            },
+        },
+        .number_line = .{
+            .pos = .{ .col = @intCast(padding_width) },
             .dims = .{
                 .height = term_dims.height,
                 .width = number_line_width,
             },
         },
         .buffer = .{
-            .pos = .{ .col = number_line_width },
+            .pos = .{ .col = @intCast(occupied_width) },
             .dims = .{
                 .height = term_dims.height,
-                .width = term_dims.width - number_line_width,
+                .width = term_dims.width - occupied_width,
             },
         },
     };
