diff --git a/src/buffer.zig b/src/buffer.zig
index c3c8474..9512727 100644
--- a/src/buffer.zig
+++ b/src/buffer.zig
@@ -23,9 +23,10 @@ const lsp = @import("lsp.zig");
 const main = @import("main.zig");
 const ter = @import("terminal.zig");
 const ts = @import("ts.zig");
-const dia = @import("ui/diagnostic.zig");
 const uni = @import("unicode.zig");
 const uri = @import("uri.zig");
+const dia = @import("ui/diagnostic.zig");
+const fzf = @import("ui/fzf.zig");
 
 pub const Buffer = struct {
     path: []const u8,
@@ -363,7 +364,7 @@ pub const Buffer = struct {
         main.editor.dirty.completion = true;
     }
 
-    pub fn commitChanges(self: *Buffer) FatalError!void {
+    pub fn commitChanges(self: *Buffer) !void {
         if (self.uncommitted_changes.items.len == 0) {
             log.debug(@This(), "no changes to commit\n", .{});
             return;
@@ -598,6 +599,27 @@ pub const Buffer = struct {
         }
     }
 
+    pub fn findSymbols(self: *Buffer) !void {
+        if (self.ts_state) |*ts_state| {
+            if (ts_state.symbol) |*parse_result| {
+                try parse_result.makeSpans(ts_state.tree.?);
+                for (parse_result.spans.items) |span| {
+                    const symbol_name = self.content_raw.items[span.start..span.end];
+                    log.debug(@This(), "symbol span: {s}\n", .{symbol_name});
+                }
+                const pick_result = fzf.pickSymbol(self.allocator, self, parse_result.spans.items) catch |e| {
+                    log.err(@This(), "{}\n", .{e});
+                    if (@errorReturnTrace()) |trace| log.errPrint("{f}\n", .{trace.*});
+                    return;
+                };
+                defer self.allocator.free(pick_result.path);
+                log.debug(@This(), "picked symbol: {}\n", .{pick_result});
+                self.moveCursor(pick_result.position);
+                self.centerCursor();
+            }
+        }
+    }
+
     pub fn showHover(self: *Buffer) !void {
         for (self.lsp_connections.items) |conn| {
             try conn.hover();
diff --git a/src/core.zig b/src/core.zig
index 1d21d32..3ae092b 100644
--- a/src/core.zig
+++ b/src/core.zig
@@ -89,6 +89,11 @@ pub const ByteSpan = struct {
     start: usize,
     end: usize,
 
+    pub fn init(span: ByteSpan, capture_name: []const u8) ?ByteSpan {
+        if (!std.mem.eql(u8, capture_name, "name")) return null;
+        return span;
+    }
+
     pub fn fromBufSpan(buffer: *const buf.Buffer, span: Span) ByteSpan {
         return .{
             .start = buffer.cursorToBytePos(span.start),
diff --git a/src/file_type.zig b/src/file_type.zig
index 9ae77c4..de1b233 100644
--- a/src/file_type.zig
+++ b/src/file_type.zig
@@ -19,6 +19,7 @@ pub const file_type = std.StaticStringMap(FileTypeConfig).initComptime(.{
             .lib_symbol = "tree_sitter_typescript",
             .highlight_query = TsConfig.highlight_query_from_nvim("ecma"),
             .indent_query = TsConfig.highlight_query_from_nvim("ecma"),
+            .symbol_query = TsConfig.symbol_query_from_aerial("ecma"),
         },
     } },
     .{ ".zig", FileTypeConfig{
@@ -27,7 +28,9 @@ pub const file_type = std.StaticStringMap(FileTypeConfig).initComptime(.{
     } },
 });
 
-const nvim_ts_path = "$HOME/.local/share/nvim/lazy/nvim-treesitter";
+const nvim_runtime_path = "$HOME/.local/share/nvim";
+const nvim_ts_path = nvim_runtime_path ++ "/lazy/nvim-treesitter";
+const nvim_aerial_path = nvim_runtime_path ++ "/lazy/aerial.nvim";
 
 pub const FileTypeConfig = struct {
     name: []const u8,
@@ -40,6 +43,7 @@ pub const TsConfig = struct {
     lib_symbol: []const u8,
     highlight_query: []const u8,
     indent_query: []const u8,
+    symbol_query: ?[]const u8,
 
     pub fn from_nvim(comptime name: []const u8) TsConfig {
         return .{
@@ -47,6 +51,7 @@ pub const TsConfig = struct {
             .lib_symbol = "tree_sitter_" ++ name,
             .highlight_query = highlight_query_from_nvim(name),
             .indent_query = indent_query_from_nvim(name),
+            .symbol_query = symbol_query_from_aerial(name),
         };
     }
 
@@ -78,6 +83,10 @@ pub const TsConfig = struct {
     pub fn indent_query_from_nvim(comptime name: []const u8) []const u8 {
         return nvim_ts_path ++ "/queries/" ++ name ++ "/indents.scm";
     }
+
+    pub fn symbol_query_from_aerial(comptime name: []const u8) []const u8 {
+        return nvim_aerial_path ++ "/queries/" ++ name ++ "/aerial.scm";
+    }
 };
 
 pub const plain: FileTypeConfig = .{ .name = "plain", .ts = null };
diff --git a/src/main.zig b/src/main.zig
index 69bf3f9..cd63427 100644
--- a/src/main.zig
+++ b/src/main.zig
@@ -350,7 +350,9 @@ pub fn startEditor(allocator: std.mem.Allocator) FatalError!void {
                         buffer.findReferences() catch |e| log.err(@This(), "find references LSP error: {}\n", .{e});
                     } else if (editor.mode == .normal and eql(u8, multi_key, " n")) {
                         try buffer.renamePrompt();
-                    } else if (editor.mode == .normal and eql(u8, key, "r") and key2.printable != null) {
+                    } else if (editor.mode == .normal and eql(u8, multi_key, " f")) {
+                        try buffer.findSymbols();
+                    } else if (editor.mode == .normal and eql(u8, key, "r") and editor.key_queue.items[1].printable != null) {
                         const macro_name: u8 = @intCast(key2.printable.?);
                         try editor.startMacro(macro_name);
                     } else if (editor.mode == .normal and eql(u8, key, "@") and key2.printable != null) {
diff --git a/src/ts.zig b/src/ts.zig
index 994aa04..42eef83 100644
--- a/src/ts.zig
+++ b/src/ts.zig
@@ -71,6 +71,7 @@ pub const State = struct {
     tree: ?*ts.TSTree = null,
     highlight: ParseResult(AttrsSpan),
     indent: ParseResult(IndentSpanTuple),
+    symbol: ?ParseResult(ByteSpan) = null,
     allocator: Allocator,
 
     pub fn init(allocator: Allocator, ts_conf: ft.TsConfig) !State {
@@ -79,14 +80,18 @@ pub const State = struct {
         defer allocator.free(highlight_query);
         const indent_query = try ft.TsConfig.loadQuery(allocator, ts_conf.indent_query);
         defer allocator.free(indent_query);
+        const symbol_query = if (ts_conf.symbol_query) |sq| try ft.TsConfig.loadQuery(allocator, sq) else null;
+        defer if (symbol_query) |sq| allocator.free(sq);
 
-        const self = State{
+        var self = State{
             .parser = ts.ts_parser_new(),
             .allocator = allocator,
             .highlight = try ParseResult(AttrsSpan).init(allocator, language(), highlight_query),
             .indent = try ParseResult(IndentSpanTuple).init(allocator, language(), indent_query),
         };
+        if (symbol_query) |sq| self.symbol = try ParseResult(ByteSpan).init(allocator, language(), sq);
         _ = ts.ts_parser_set_language(self.parser, language());
+
         return self;
     }
 
@@ -114,6 +119,7 @@ pub const State = struct {
         if (self.tree) |t| ts.ts_tree_delete(t);
         self.highlight.deinit();
         self.indent.deinit();
+        if (self.symbol) |*s| s.deinit();
     }
 };
 
diff --git a/src/ui/fzf.zig b/src/ui/fzf.zig
index 3852c7a..7c71e67 100644
--- a/src/ui/fzf.zig
+++ b/src/ui/fzf.zig
@@ -5,6 +5,7 @@ const buf = @import("../buffer.zig");
 const col = @import("../color.zig");
 const core = @import("../core.zig");
 const Cursor = core.Cursor;
+const ByteSpan = core.ByteSpan;
 const ext = @import("../external.zig");
 const log = @import("../log.zig");
 const lsp = @import("../lsp.zig");
@@ -26,7 +27,7 @@ pub const FindResult = struct {
     position: Cursor,
 
     pub fn init(allocator: Allocator, fzf_out: []const u8) !FindResult {
-        var iter = std.mem.splitScalar(u8, fzf_out, ':');
+        var iter = std.mem.splitScalar(u8, std.mem.trimEnd(u8, fzf_out, "\n"), ':');
         return .{
             .path = try allocator.dupe(u8, iter.next().?),
             .position = .{
@@ -89,6 +90,32 @@ pub fn pickLspLocation(allocator: Allocator, locations: []const lsp.types.Locati
     return .init(allocator, out);
 }
 
+pub fn pickSymbol(allocator: Allocator, buffer: *const buf.Buffer, symbols: []const ByteSpan) !FindResult {
+    var lines: std.io.Writer.Allocating = .init(allocator);
+    defer lines.deinit();
+    for (symbols) |symbol| {
+        const pos = buffer.posToCursor(symbol.start);
+        const symbol_name = buffer.content_raw.items[symbol.start..symbol.end];
+        try lines.writer.print(
+            "{s}:{}:{}\n",
+            .{ symbol_name, pos.row + 1, pos.col + 1 },
+        );
+    }
+
+    const preview_cmd = try std.fmt.allocPrint(
+        allocator,
+        "hat --printer --term-height=$FZF_PREVIEW_LINES --highlight-line={{2}} {s}",
+        .{buffer.path},
+    );
+    defer allocator.free(preview_cmd);
+
+    const cmd: []const []const u8 = fzf_command ++ .{ "--preview", preview_cmd, "--delimiter", ":" };
+    const out = try ext.runExternalWait(allocator, cmd, lines.written(), null);
+    defer allocator.free(out);
+    if (out.len == 0) return error.EmptyOut;
+    return .init(allocator, out);
+}
+
 const fzf_cmd_with_preview: []const []const u8 = fzf_command ++ .{
     "--preview",
     "hat --printer --term-height=$FZF_PREVIEW_LINES --highlight-line={2} {1}",
