diff --git a/src/buffer.zig b/src/buffer.zig
index f66ebf1..a23bd61 100644
--- a/src/buffer.zig
+++ b/src/buffer.zig
@@ -241,14 +241,6 @@ pub const Buffer = struct {
         _ = try self.syncFs();
 
         self.file_history_index = self.history_index;
-
-        const msg = try std.fmt.allocPrint(
-            self.allocator,
-            "{s} {}B written",
-            .{ self.path, self.content_raw.items.len },
-        );
-        defer self.allocator.free(msg);
-        try main.editor.sendMessage(msg);
     }
 
     pub fn moveCursor(self: *Buffer, new_cursor: Cursor) void {
@@ -498,6 +490,11 @@ pub const Buffer = struct {
         self.history_index = self.history.items.len - 1;
 
         main.editor.dotRepeatCommitReady();
+
+        if (edi.Config.autosave) {
+            log.debug(@This(), "autosave {s}\n", .{self.path});
+            self.write() catch |e| log.err(@This(), "write buffer error: {}", .{e});
+        }
     }
 
     pub fn changeInsertText(self: *Buffer, text: []const u21) FatalError!void {
@@ -623,6 +620,11 @@ pub const Buffer = struct {
                 self.moveCursor(inv_change.new_span.?.start);
             }
             self.history_index = if (h_idx > 0) h_idx - 1 else null;
+
+            if (edi.Config.autosave) {
+                self.write() catch |e| log.err(@This(), "write buffer error: {}", .{e});
+                log.debug(@This(), "autosave {s}\n", .{self.path});
+            }
         }
     }
 
@@ -638,6 +640,11 @@ pub const Buffer = struct {
             self.moveCursor(change.new_span.?.start);
         }
         self.history_index = redo_idx;
+
+        if (edi.Config.autosave) {
+            self.write() catch |e| log.err(@This(), "write buffer error: {}", .{e});
+            log.debug(@This(), "autosave {s}\n", .{self.path});
+        }
     }
 
     pub fn textAt(self: *const Buffer, span: Span) []const u21 {
diff --git a/src/editor.zig b/src/editor.zig
index 8986a02..8d412aa 100644
--- a/src/editor.zig
+++ b/src/editor.zig
@@ -24,6 +24,7 @@ pub const Config = struct {
     /// Attempt to find matching pair when cursor is over one of these [start, end] chars
     /// If start == end, will only check forward until first encountered match
     pub const matching_pair_chars: ?[]const [2]u21 = &.{ .{ '{', '}' }, .{ '[', ']' }, .{ '(', ')' }, .{ '<', '>' }, .{ '|', '|' } };
+    pub const autosave: bool = false;
 };
 
 pub const Dirty = struct {
